{"root":{"data":{"id":"d34elc5upa80","created":1722498032757,"text":"Flutter组件"},"children":[{"data":{"id":"d34elxsikq80","created":1722498079840,"text":"无状态组件","layout_mind_offset":{"x":7,"y":2}},"children":[{"data":{"id":"d34en39tpb40","created":1722498170135,"text":"StatelessWidget"},"children":[{"data":{"id":"d34f28ddkww0","created":1722499356696,"text":"基础布局"},"children":[]},{"data":{"id":"d34f294dcew0","created":1722499358328,"text":"进阶布局"},"children":[]},{"data":{"id":"d34f29u111c0","created":1722499359880,"text":"风格组件"},"children":[]},{"data":{"id":"d34hjot0ojs0","created":1722506366881,"text":"滚动布局","note":"相信使用过一段时间Flutter的开发者应该或多或少听说过Sliver这个词。从Flutter开发者社区讨论中也可以看出，不少人对Sliver这个概念很迷惑，甚至产生了抵触的情绪。其实sliver在英文里是“片段”的意思，例如一小块奶酪（a sliver of cheese）、月牙（a sliver of the moon）、一丝希望（a sliver of hope）等都可以用这个单词。\n在Flutter中，Sliver是指滚动视窗中的一小块区域。不同于普通的RenderBox主导的布局，Sliver组件的背后是由遵守“Sliver协议”的RenderSliver负责渲染，支持动态加载，在元素较多时非常高效。Sliver组件名称一般由Sliver...开头，在与普通的组件混搭时需要转换协议；"},"children":[{"data":{"id":"d34hkkw6krk0","created":1722506436729,"text":"SliverToBoxAdapter","note":"SliverToBoxAdapter组件就可帮助开发者将常见的RenderBox布局协议转换为Sliver协议。布局时，它首先将父级约束SliverConstraints转换为BoxConstraints，布局完毕后再将子组件最终确定的Size转换为SliverGeometry并汇报给父级组件。\n另外，SliverToBoxAdapter的子组件（child属性）非必传。若子组件为空，则该组件可作为一个空白Sliver使用，其功能类似RenderBox世界中的空白SizedBox组件"},"children":[]}]}]}]},{"data":{"id":"d34em9h6o5s0","created":1722498105276,"text":"有状态组件","layout_mind_offset":{"x":7,"y":106}},"children":[{"data":{"id":"d34en8afmog0","created":1722498181055,"text":"StatefulWidget"},"children":[{"data":{"id":"d34f28ddkww0","created":1722499356696,"text":"基础布局"},"children":[]},{"data":{"id":"d34f294dcew0","created":1722499358328,"text":"进阶布局"},"children":[]},{"data":{"id":"d34f29u111c0","created":1722499359880,"text":"风格组件"},"children":[]}]}]},{"data":{"id":"d34emerrd3k0","created":1722498116800,"text":"继承式组件","layout_mind_offset":{"x":641,"y":-193},"note":"其主要作用是将任意信息方便且高效地传递给组件树中的所有下级组件。\n一般情况下，若将某些数据传给子组件，开发者需通过在子组件的构造函数中直接添加参数实现。例如Text组件就是通过接收一个字符串获取需要渲染的数据，但当组件嵌套多层，而数据又需要被深层的下级组件访问时，若通过上述办法，层层传递参数则可能会使代码显得凌乱，使用继承式组件就可以很好地解决这个问题。\n示例：\nclass MyInheritedColor extends InheritedWidget {\n\n  final Color textColor;\n\n  const MyInheritedColor(this.textColor, {super.key, required super.child});\n\n  @override\n  bool updateShouldNotify(covariant MyInheritedColor oldWidget) {\n    // TODO: implement updateShouldNotify\n    return oldWidget.textColor != textColor;\n  }\n  static  MyInheritedColor? of(BuildContext context) => context.dependOnInheritedWidgetOfExactType<MyInheritedColor>();\n}","priority":null,"background":"#ff0000","color":"#ffffff"},"children":[{"data":{"id":"d34emykm3u00","created":1722498159903,"text":"InheritedWidget"},"children":[]}]},{"data":{"id":"d34fd550d9s0","created":1722500211665,"text":"动画","layout_mind_offset":{"x":630,"y":-4},"note":"当动画需要精确控制时，使用显示动画\n否则就选择隐式动画\n当Flutter框架提供的隐式动画和显式动画组件都不足以满足实际需求时，也可以考虑使用TweenAnimationBuilder自定义隐式动画，或使用AnimatedBuilder自定义显式动画。尤其是后者，若再配合CustomPaint等支持随意绘制的画布组件，则更可完成一切动画需求，但显然这么做难免会增加代码的难度，延长开发周期，因此实战中选择合适的动画组件相对重要。\n\n\n显式动画组件通常以...Transition结尾，如FadeTransition、SlideTransition、SizeTransition等。在使用显式动画时，开发者需要自行创建并维护一个AnimationController（动画控制器），通过它来控制动画的开始、暂停、重置、跳转、倒播等操作。\n"},"children":[{"data":{"id":"d34fd8x0bgo0","created":1722500219889,"text":"显式动画Animated..."},"children":[]},{"data":{"id":"d34fdfvz3fs0","created":1722500235064,"text":"隐式动画...Transition"},"children":[]}]},{"data":{"id":"d3kc7b1u3r40","created":1724116250326,"text":"常用组件"},"children":[{"data":{"id":"d3kc7mo0iw00","created":1724116275612,"text":"FlutterLogo"},"children":[]},{"data":{"id":"d3kc7z6i8vc0","created":1724116302851,"text":"PlaceHolder"},"children":[]},{"data":{"id":"d3kc84idndc0","created":1724116314453,"text":"Container"},"children":[]},{"data":{"id":"d3khjkxv3mw0","created":1724131317773,"text":"拆分布局"},"children":[{"data":{"id":"d3kc8944mv40","created":1724116324476,"text":"Column"},"children":[]},{"data":{"id":"d3kc8d6res80","created":1724116333342,"text":"Row"},"children":[]},{"data":{"id":"d3kc8f3ido00","created":1724116337499,"text":"Wrap"},"children":[]},{"data":{"id":"d3kc8j7ruu00","created":1724116346464,"text":"Stack"},"children":[]}]},{"data":{"id":"d3khj0ze4rs0","created":1724131274330,"text":"位置"},"children":[{"data":{"id":"d3kc8l1lwkg0","created":1724116350444,"text":"Positioned","layout_left_offset":{"x":-44,"y":3}},"children":[]},{"data":{"id":"d3kc8r1f7v40","created":1724116363494,"text":"SizedBox","layout_left_offset":{"x":-44,"y":3}},"children":[]},{"data":{"id":"d3kc8xu6law0","created":1724116378295,"text":"Center","layout_left_offset":{"x":-44,"y":3}},"children":[]},{"data":{"id":"d3kc906r0yo0","created":1724116383407,"text":"Align"},"children":[]}]},{"data":{"id":"d3kc959jffc0","created":1724116394460,"text":"文字和图片"},"children":[{"data":{"id":"d3kh5r2kkq80","created":1724130234020,"text":"Text"},"children":[]},{"data":{"id":"d3kh5ub5aw80","created":1724130241069,"text":"RichText"},"children":[]},{"data":{"id":"d3kh5x1gd7s0","created":1724130247014,"text":"DefaultTextStyle"},"children":[]},{"data":{"id":"d3kh62xt7t40","created":1724130259854,"text":"Icon"},"children":[]},{"data":{"id":"d3kh66bebx40","created":1724130267206,"text":"IconTheme"},"children":[]},{"data":{"id":"d3kh67oeb7k0","created":1724130270169,"text":"Image"},"children":[]},{"data":{"id":"d3kh69sv1eo0","created":1724130274792,"text":"FadeInImage","note":"若需要在图片加载的过程中暂时显示另一张替代图片，并在图片加载完毕后平滑过渡，就可以使用FadeInImage组件。通常替代图片可被迅速加载，而原图可能会耗时较久。作为替代的素材图片通常可以是一张本地资源包图片（如一个可爱的“正在努力加载哟”的GIF动图）或是一张能较快加载的小图（如预览图或缩略图）等。","progress":9,"priority":null},"children":[]}]},{"data":{"id":"d3kh6wmzsm80","created":1724130324503,"text":"交互"},"children":[{"data":{"id":"d3kh72kml940","created":1724130337421,"text":"TextField"},"children":[]},{"data":{"id":"d3kh76v953s0","created":1724130346771,"text":"CupertinoTextfield"},"children":[]},{"data":{"id":"d3kh7gzgt9s0","created":1724130368793,"text":"TextButton"},"children":[]},{"data":{"id":"d3kh7iro1dc0","created":1724130372675,"text":"ElevateButton"},"children":[]},{"data":{"id":"d3kh7p1w1qo0","created":1724130386354,"text":"CupertinoButton"},"children":[]},{"data":{"id":"d3kh7u0dvvk0","created":1724130397147,"text":"GestureDetector"},"children":[]}]},{"data":{"id":"d3kh85yqcyg0","created":1724130423168,"text":"异步操作"},"children":[{"data":{"id":"d3kh8o9195s0","created":1724130462973,"text":"CircularProgressIndicator"},"children":[]},{"data":{"id":"d3kh92eqd2o0","created":1724130493793,"text":"LinerProgressIndicator"},"children":[]},{"data":{"id":"d3kh99t5v4w0","created":1724130509903,"text":"CupertinoActivityIndicator"},"children":[]},{"data":{"id":"d3kh9p12r2g0","created":1724130543034,"text":"FutureBuilder"},"children":[]},{"data":{"id":"d3kh9sy3ifc0","created":1724130551560,"text":"StreamBuilder"},"children":[]}]},{"data":{"id":"d3kha67chso0","created":1724130580418,"text":"列表和网格"},"children":[{"data":{"id":"d3khafcua140","created":1724130600341,"text":"ListView"},"children":[]},{"data":{"id":"d3khahqh8mg0","created":1724130605519,"text":"ListWheelScrollView"},"children":[]},{"data":{"id":"d3khayjo8bc0","created":1724130642113,"text":"ReorderbalListView"},"children":[]},{"data":{"id":"d3khb6qr0280","created":1724130659955,"text":"GridView"},"children":[]},{"data":{"id":"d3khb98w7zc0","created":1724130665406,"text":"PageView"},"children":[]}]},{"data":{"id":"d3kha976n8g0","created":1724130586938,"text":"滚动控制和监听"},"children":[{"data":{"id":"d3khbxbqm880","created":1724130717820,"text":"ScrollBar"},"children":[]},{"data":{"id":"d3khc1l4qc80","created":1724130727095,"text":"RefreshIndicator","note":"RefreshIndicator（刷新指示器）组件可为大部分滚动列表添加“下拉刷新”的功能，但它目前只支持垂直方向滚动的列表。使用时只需要在滚动列表（如ListView）组件的父级插入RefreshIndicator组件，并通过onRefresh参数传入刷新时的业务逻辑","progress":9},"children":[]},{"data":{"id":"d3khcaasz340","created":1724130746062,"text":"Dismissible","note":"Dismissible原意是“可被清除的”，因此这个Flutter组件主要用于帮助开发者实现看似复杂的“滑动清除”效果。例如，在电子邮箱管理软件中经常可以看到滑动即可删除某封电子邮件的功能。这个组件最常放在ListView之类的列表中，作为列表children的每个Widget的父级组件，为所有元素添加滑动清除功能，但Dismissible也可被用于其他任何接收Widget类型的场景。\n使用时需要在可被清除的组件的父级插入Dismissible，并传入一个key（键）。如可在ListView组件的itemBuilder中返回Dismissible组件并利用child属性继续指定子组件","progress":9},"children":[]},{"data":{"id":"d3khd97eeww0","created":1724130822044,"text":"ScrollConfiguration","note":"如果需要改变一部分或全部列表的默认样式，则可以使用ScrollConfiguration组件。这种思路与同时设置所有子Text组件的DefaultTextStyle组件，或同时设置所有子Icon组件的IconTheme组件类似，所有列表类组件的默认样式是由最近上级的ScrollConfiguration组件提供的，因此，若需要全局设置整个应用程序的所有列表默认样式，则可将ScrollConfiguration组件插入接近组件树根部的位置。若只需设置某个列表的默认样式，则应把ScrollConfiguration组件直接插入该列表组件的父级，从而避免干扰到其他的列表。","progress":9},"children":[]},{"data":{"id":"d3khduon3nc0","created":1724130868799,"text":"NotificationListener","note":"滚动类的列表组件如ListView或GridView等，在滚动的过程中会产生滚动通知事件。这类通知事件会沿着组件树向上冒泡（Bubble Up），直到被某个监听该通知事件的组件拦截为止。\n也可以监听来自Notification发送的事件","progress":9},"children":[]},{"data":{"id":"d3khdxkseog0","created":1724130875096,"text":"SigleChildScrollerView","progress":9},"children":[]}]},{"data":{"id":"d3khlll61vk0","created":1724131475911,"text":"边界"},"children":[{"data":{"id":"d3kjns8a3hs0","created":1724137289317,"text":"Padding"},"children":[]},{"data":{"id":"d3kjntolrwo0","created":1724137292481,"text":"SafeArea"},"children":[]},{"data":{"id":"d3kjnwbbpqg0","created":1724137298208,"text":"FittedBox","note":"当父级组件与子组件的尺寸或比例不符合时，FittedBox可以将子组件缩放并对齐。使用时，只需要在父级与子级组件之间插入FittedBox组件\n\n运行时，根据父级组件的尺寸约束，FittedBox会自动将其child缩放，以尽量填满父级组件的全部可用空间。FittedBox对子组件没有特殊要求，例如在实战中，FittedBox经常被用于在复杂的布局场景中轻松实现自动字号调节"},"children":[]},{"data":{"id":"d3kjo0hszxk0","created":1724137307307,"text":"MediaQuery","note":"MediaQuery是一个帮助开发者获取设备信息的继承式组件（InheritedWidget），通过它可查询设备的屏幕尺寸或当前是否为横屏状态，以及用户是否在系统偏好里设置了较大的字号，是否关闭了动画，是否开启了夜间模式等。\n实战中访问MediaQuery非常容易，只需调用MediaQuery.of静态方法，并将当前的BuildContext传给它。"},"children":[]}]},{"data":{"id":"d3khlrcj9uw0","created":1724131488449,"text":"弹性布局"},"children":[{"data":{"id":"d3kjowv6hko0","created":1724137377773,"text":"Flex"},"children":[]},{"data":{"id":"d3kjozp8euo0","created":1724137383944,"text":"Expanded"},"children":[]},{"data":{"id":"d3kjp1fey7s0","created":1724137387704,"text":"Flexible","note":"Flexible是Expanded组件的父类，主要作用也是用于“扩张”Flex中的部分组件，使它们占满全部空间。\nFlexible组件同样有flex属性，用于表示该组件相对于其他弹性组件（如Expanded或Flexible组件）的“弹性权重”。与Expanded组件不同的是，Flexible还可以通过fit属性设置其child是否必须占满Flexible为其扩张出的空间，而Expanded组件的child就没有这个选择的权利，必须占满。\nfit属性可以接收FlexFit.tight或FlexFit.loose这两个值。若设置为tight（紧约束），则该Flexible组件与Expanded组件效果完全一致，强制约束子组件的尺寸必须为Flexible分配的尺寸，不可以更大或更小，而传入loose（宽松）则允许子组件的尺寸小于或等于所分配的尺寸。此时，若某些子组件真的选择渲染更小的尺寸，则它们节约出的多余空间也不会再被分配给其他组件。\n\n"},"children":[]},{"data":{"id":"d3kjp3tg1ow0","created":1724137392906,"text":"Spacer"},"children":[]}]},{"data":{"id":"d3khltevs4g0","created":1724131492945,"text":"约束"},"children":[{"data":{"id":"d3kjp9ykqn40","created":1724137406277,"text":"ConstrainedBox"},"children":[]},{"data":{"id":"d3kjpdbcry00","created":1724137413580,"text":"LimittedBox"},"children":[]},{"data":{"id":"d3kjpnooepc0","created":1724137436153,"text":"LayoutBuilder"},"children":[]},{"data":{"id":"d3kjpq09cq00","created":1724137441207,"text":"FractionallySizedBox"},"children":[]}]},{"data":{"id":"d3khlvll0kg0","created":1724131497704,"text":"过渡动画"},"children":[{"data":{"id":"d3kj8kvm7vc0","created":1724136097852,"text":"渐变效果"},"children":[{"data":{"id":"d3kj8r7pudc0","created":1724136111644,"text":"AnimatedContainer","note":"AnimatedContainer组件是常用的Container组件的动画版本。它与普通Container的主要区别在于，每当它的外观属性发生变化时，它会自动实现从旧的属性值到新的属性值的渐变切换。开发者唯一要做的就是通过duration参数设置渐变动画的总时长，非常方便。"},"children":[]},{"data":{"id":"d3kj8y1m7z40","created":1724136126512,"text":"AnimatedPadding","note":"正如AnimatedContainer是Container组件的动画版本，AnimatedPadding是Padding组件的动画版本。它与第6章介绍的普通Padding组件的区别在于，每当留白的值（padding属性）发生变化时，AnimatedPadding会自动实现从旧的留白值到新的留白值的渐变切换。"},"children":[]},{"data":{"id":"d3kj94dy3a00","created":1724136140319,"text":"AnimatedPositioned","note":"AnimatedPositioned是Positioned组件的动画版本。它必须在Stack中使用。每当表示位置和尺寸的top、bottom、left、right或width和height属性发生改变时，AnimatedPositioned就会自动触发从旧的属性值到新的属性值的渐变动画效果。\n同一维度的3个属性（横轴left、right、width属性，以及纵轴top、bottom、height属性）最多只可以传入2个。例如传入left：100和right：100后，子组件的宽度就必须为左右两边留白100单位后剩余的全部宽度，而传入left：100和width：50则表示左边留白100单位且固定子组件宽度为50单位，那么它的右边就必须留白剩余的全部空间。此处需注意，同时传入同一维度的3个属性会导致运行时错误。\n利用这一原理，AnimatedPositioned组件不仅可实现子组件在Stack容器中位置的渐变，还可同时支持它们的尺寸渐变\n\n注意：由于AnimatedPositioned在渐变的过程中，子组件的尺寸和位置都有可能会发生改变，因此它在计算每帧动画时除了要重新布局（re-layout）外，还需要通知子组件重新绘制（re-paint）。若子组件的尺寸并不需要变动，开发者则可以考虑直接使用AnimatedPadding或其他不会导致子组件重绘的动画组件，以节省计算量，从而增强性能。"},"children":[]},{"data":{"id":"d3kj9g8rrcg0","created":1724136166127,"text":"AnimatedOpacity","note":"AnimatedOpacity是Opacity组件的动画版本，后者主要负责通过opacity（不透明度）属性，修改子组件的不透明度。例如当它的opacity值为0.5时，其child会被渲染为半透明。\n\n值得指出的是，用于修改不透明度的Opacity组件对设备性能要求较高，因为它需要先将子组件渲染至缓冲区（Intermediate Buffer），再对其修改不透明度，最后才能完成渲染。读者可以粗略地理解为它需要先将child渲染至一个独立的图层，对该图层进行半透明处理，再与其他组件及背景混色，最后才能呈现出效果。可想而知，由于AnimatedOpacity组件在其动画的过程中需要连续修改不透明度，因此它也属于性能较差的组件。"},"children":[]},{"data":{"id":"d3kj9lvmrp40","created":1724136178393,"text":"AnimatedDefaultTextStyle","note":"AnimatedDefaultTextStyle是DefaultTextStyle组件的动画版本，而普通的DefaultTextStyle组件是负责为组件树下级的Text组件提供默认样式的一个继承式组件，主要用于统一修改多个Text组件的文本样式，如字体、字号、粗细、颜色、渲染特效等。\n\n需要指出的是，并不是所有DefaultTextStyle支持的属性都会被自动添加渐变效果。其中当textAlign（对齐方式）、softWrap（自动换行）、overflow（溢出）或maxLines（最大行数）等属性值发生变化时，AnimatedDefaultTextStyle会立即采用新的值，而没有渐变效果。"},"children":[]}]},{"data":{"id":"d3kj8ny19uw0","created":1724136104528,"text":"组件切换"},"children":[{"data":{"id":"d3kj9uv9a3s0","created":1724136197962,"text":"AnimatedSwitcher","note":"AnimatedSwitcher可在子组件被替换时，在旧的组件与新的组件之间插入过渡动画，默认为交叉淡入淡出效果。例如，当加载完成时从显示一个进度条渐变为显示FlutterLogo组件\n\nAnimatedSwitcher的默认动画效果为淡入淡出，而该默认行为可由transtionBuilder参数配合FadeTranstion、ScaleTranstion、RotationTranstion等显式动画组件轻易修改。\n\n通过修改layoutBuilder回传函数，开发者也可以指定任意其他渐变动画时的布局方式。其中，layoutBuilder传入的currentChild参数为当前正在切入的新组件，而previousChildren列表则是当前正在切出的若干个旧组件。每当AnimatedSwitcher的child属性改变时，它就会为最新的child组件开始一段渐变动画，而旧的组件此时不一定已经完成了之前的淡出效果，因此若child切换得足够频繁，就很有可能出现数个旧组件同时存在的情况。"},"children":[]},{"data":{"id":"d3kj9yg8e9s0","created":1724136205760,"text":"AnimatedCrossFade","note":"当程序界面只需要在2个组件之间来回切换时，除了7.2.1节介绍的AnimatedSwitcher外，也可以考虑使用专门为切换2个子组件而设计的AnimatedCrossFade动画组件。\n使用时，需要把2个组件分别传给firstChild和secondChild参数，之后除了通过duration设置动画时长外，还需要用crossFadeState参数指定当前应该显示第1个还是第2个组件，"},"children":[]}]}]},{"data":{"id":"d3khlyprunc0","created":1724131504487,"text":"触摸检测"},"children":[{"data":{"id":"d3kj4kk52ig0","created":1724135783701,"text":"GestureDetector"},"children":[]},{"data":{"id":"d3kj4nrxthc0","created":1724135790703,"text":"Listener","note":"Listener是一个较为底层的组件，用于监听最原始的触碰事件.\nListener可以监听的底层事件有onPointerDown、onPointerMove、onPointerUp、onPointerCancel、onPointerSignal等，用法与GestureDetector大同小异。这里选用down、up和move这3种事件演示Listener的基本用法，监听按下和抬起的操作，以及汇报指针的坐标。"},"children":[]},{"data":{"id":"d3kj4s4h91c0","created":1724135800168,"text":"MouseRegion","note":"鼠标区域组件可用于监听与鼠标相关的事件，用法与Listener相似"},"children":[]},{"data":{"id":"d3kj4yhhwa00","created":1724135814016,"text":"IgnorePointer","note":"当需要选择性禁用某些页面元素时，可以使用IgnorePointer组件忽略指针。用法非常简单，只需将其插入在需要忽略用户交互事件的组件父级"},"children":[]},{"data":{"id":"d3kj544krhc0","created":1724135826295,"text":"AbsorbPointer","note":"AbsorbPointer也可被用于禁用某些元素。不同之处在于，IgnorePointer组件用于忽略触摸事件，而AbsorbPointer则用于“吸收”或“吞掉”这些事件，确保其他组件（如在Stack的底层的其他组件）也不会接收到这些被“吞掉”的事件。\n例如当Stack的底层存在一个GestureDetector正在监听，并在其之上还有一个按钮时，若使用AbsorbPointer吸收事件，可确保按钮无法单击，且单击事件不会再传给底层的GestureDetector组件，而若使用IgnorePointer，则当按钮不可单击时，单击事件可“穿透”至底层"},"children":[]}]},{"data":{"id":"d3khm7brcf40","created":1724131523231,"text":"拖放"},"children":[{"data":{"id":"d3kix37zyvs0","created":1724135197412,"text":"Draggable","note":"当需要为某个组件添加拖动支持时，可在该组件的父级插入Draggable组件，并提供必传参数。除了child属性外，Draggable组件还有必传的feedback属性，即当子组件被拖动时需渲染在指尖或光标下的“反馈”组件。\n例如可用一个深灰色的Container组件作为Draggable的child属性，再用一个稍浅灰色的Container组件作为其feedback属性"},"children":[]},{"data":{"id":"d3kix4vllwg0","created":1724135201016,"text":"DragTarget","note":"拖放目标是一个可用于接收Draggable的组件。当一个Draggable被用户拖动到DragTarget的区域内时，Flutter会先调用DragTarget的onWillAccept函数，询问该目标是否愿意接收。若目标组件愿意接收，且用户确实将Draggable丢放于此（抬起手指或松开鼠标按钮），则目标DragTarget组件的onAccept函数会被调用，使其接收Draggable的数据。\nDragTarget只可能接收同类型的Draggable，因此在使用DragTarget之前，应先为Draggable添加data属性和通用类型（Generic，也译作泛型）参数。例如可将其设置为String类型\n使用DragTarget时也需指定同样的通用类型，如DragTarget<String>等。不同通用类型的Draggable和DragTarget无法匹配，因此不会产生互动。例如Draggable<MyType>与DragTarget<int>由于通用类型不同，无论用户怎么拖动，都不会触发相应的onWillAccept等事件。\n然而实战中，也有可能出现某Draggable组件匹配了正确的通用类型，但其data属性却是null的情况，例如开发者可能忘记设置Draggable的数据了，因此DragTarget收到的类型是可空的。"},"children":[]},{"data":{"id":"d3kixgymnsw0","created":1724135227321,"text":"LongPressDraggable","note":"LongPressDraggable（长按拖放）组件，顾名思义，是普通的Draggable组件的“长按”版本。使用该组件可使被拖动的组件只有在用户长按后才进入拖动状态。这种行为常见于列表中\n此外LongPressDraggable组件还增设了一个属性hapticFeedbackOnStart，用于设置是否在拖动开始时产生触觉反馈，默认开启，可以传入false关闭该功能。当开启时，Flutter会在用户开始拖动时调用HapticFeedback.selectionClick（）方法使设备发出轻微振动。"},"children":[]}]},{"data":{"id":"d3khmgjml3k0","created":1724131543298,"text":"悬浮"},"children":[{"data":{"id":"d3kiqyyxu740","created":1724134717972,"text":"OverlayEntry","note":"OverlayEntry是可被安插在Overlay中作为悬浮内容的组件。悬浮的内容永远出现在App的最顶层，且高于任何页面，因此不会受程序页面跳转所影响。当有多个悬浮内容同时出现时，最迟插入的OverlayEntry会出现在最顶层。\nOverlay组件通常不需要开发者手动创建，因为一般Flutter程序常见的组件树根MaterialApp或WidgetsApp等都会创建一个导航器（Navigator），而导航器的内部又会创建Overlay组件。Overlay的主要作用就是通过内部的Stack来管理和叠放各个组件层，包括需置顶的悬浮内容及各种不同页面之间的切换等。实战中基本可以确定当前context的组件树的上级已经存在一个Overlay组件，因此只需调用其of方法就可以查询到"},"children":[]},{"data":{"id":"d3kir1hl90g0","created":1724134723454,"text":"CompositionedTransformTarget","note":"这是一个用于设置“被追踪的目标”的组件。当该CompositedTransformTarget（目标）组件出现在屏幕上时，开发者可用配套的CompositedTransformFollower（追随者）组件追踪它的位置。\n使用时必须向CompositedTransformTarget传入link属性，类型为LayerLink。当追随者和目标使用同一个LayerLink时，追随者会被位移至目标处。此外还可以向目标传入child组件用于渲染，若不需要目标可见，则可以直接不设置child属性。\n这里需要注意的是，“目标”必须在“追随者”之前绘制，否则会导致运行时错误。在上例中，若将Stack中的2个元素的代码位置互换，就会导致“追随者”比“目标”先绘制"},"children":[]},{"data":{"id":"d3kirlf8jhc0","created":1724134766847,"text":"CompositionedTransformFllower","note":"这是一个用于设置“追随者”的组件。程序运行时，它会找到屏幕上与自己LayerLink相同的那个CompositedTransformTarget（目标）组件，并将自己位移至与目标重合。Flutter支持多个追随者追踪同一个目标，但要求目标必须比任何追随者都更早完成绘制."},"children":[]}]},{"data":{"id":"d3khmlwhmq80","created":1724131554960,"text":"弹窗"},"children":[{"data":{"id":"d3kho7310200","created":1724131679431,"text":"AlertDialog"},"children":[]},{"data":{"id":"d3khoctx7zk0","created":1724131691942,"text":"SimpleDialog","note":"这是一个Material风格的简易对话框，常用于提供多个选项并让用户选择其中一项。该对话框支持可选的title属性，用于显示一个标题以及children属性，用于提供多个选项。为保持Material风格统一，这里推荐向每个选项都传入SimpleDialogOption组件;"},"children":[]},{"data":{"id":"d3khon4w5j40","created":1724131714374,"text":"CupertinoPopupSurface","note":"这是Cupertino风格对话框的背景板，Flutter也将其作为一个组件，方便大家在此基础上继续开发。它所呈现的视觉效果是iOS系统中常见的圆角边白底模糊背景，可含一个child组件。使用时也可以通过isSurfacePainted：false将白色背景关闭，只保留模糊效果"},"children":[]},{"data":{"id":"d3kilog5ub40","created":1724134303248,"text":"ModalBarrier","note":"弹出的对话框与主程序之间通常有一层屏障，这就是ModalBarrier组件。它主要有color和dismissible这2个参数，分别用于定义颜色和是否应在轻触后自动消除。由于本章之前介绍的showDialog（）方法已经自带了barrierColor和barrierDismissible参数，可用于直接定义其自带的屏障的相应行为，因此很少需要直接使用ModalBarrier组件。\n"},"children":[]},{"data":{"id":"d3kimrpo92w0","created":1724134388718,"text":"BottomSheet"},"children":[]},{"data":{"id":"d3kimtq1wyw0","created":1724134393095,"text":"DraggableScrollableSheet","note":"这是一个可支持滚动且可被用户拖动以便改变高度的组件。它的高度在初始状态下默认为父级组件高度的50%，并可以随着用户向上和向下拖动的手势将自身的高度改为父级的25%~100%。它的内容部分通常会被渲染为一个ListView列表\n\n"},"children":[]},{"data":{"id":"d3kinudq2o80","created":1724134472890,"text":"CupertinoActionSheet","note":"这个组件负责渲染iOS风格的底部选项卡。其内容通常为数个CupertinoActionSheetAction组件所组成的选项列表，由actions参数传入，最终整个选项卡再通过showCupertinoModalPopup（）方法从屏幕下方弹出"},"children":[]}]},{"data":{"id":"d3khmp8m0io0","created":1724131562223,"text":"界面导航"},"children":[{"data":{"id":"d3khnvok0dc0","created":1724131654612,"text":"Navigator","note":"导航器通过维护内部的一个栈（stack，数据结构，不是Stack组件）来管理各个页面组件，并通过调用Overlay悬浮的方式，将多个页面叠加，以保证最新的页面显示在最顶层。同时Overlay也可以协助页面切换的过程，例如可在新页面切入的过程中不断更改新页面的位置，以实现滑入的动画效果等。"},"children":[]},{"data":{"id":"d3khnz7v5y00","created":1724131662310,"text":"WillPopScope","note":"这是一个可在当前页面即将被关闭之前否决关闭指令的组件。使用时需异步返回一个布尔值，表示是否同意关闭窗口。例如返回值为false即可阻止当前窗口被关闭;\n当需要关闭当前窗口时，只要WillPopScope组件存在于当前页面的任意位置，其onWillPop函数就会被调用。若异步返回值为true，则程序可继续正常关闭窗口，否则就会取消关闭窗口的行为。\n若存在多个WillPopScope同时可见，则Flutter会依次询问。这些WillPopScope组件均有“一票否决权”，即只有它们全部都同意关闭时，当前窗口才会被关闭。\n例如可在一个ListView列表中为每个元素添加WillPopScope组件，并设置序号为5的元素不同意关闭窗口，其他元素均同意关闭"},"children":[]},{"data":{"id":"d3kho2r5yg00","created":1724131670007,"text":"Hero","note":"在平面设计或网页设计领域中，Hero一词是指放在首页醒目位置的一个较大的横幅图片。在Flutter中，Hero组件可用于实现页面切换时，保留醒目元素始终可见，并加入渐变动画的效果。\n例如某程序在2个不同页面中使用了相同的文字或图片，借助Hero组件可为这些相同元素建立联系。具体做法是在2个页面的元素的父级都插入Hero组件，并传入相同的tag属性"},"children":[]}]},{"data":{"id":"d3khmqrjcz40","created":1724131565544,"text":"程序结构"},"children":[{"data":{"id":"d3khnd723t40","created":1724131614372,"text":"WidgetApp"},"children":[]},{"data":{"id":"d3khnfp3so00","created":1724131619816,"text":"MaterialApp"},"children":[]},{"data":{"id":"d3khnj2m8aw0","created":1724131627164,"text":"CupertinoApp"},"children":[]}]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}